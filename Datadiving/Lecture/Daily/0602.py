# 알고리즘
# 컴퓨터 과학에서 알고리즘은 입력 데이터를 받아 원하는 결과를 출력하는 과정을 말함
# 효율적인 알고리즘은 실행 시간과 자원 사용을 최소화함

# 과거 2세대애에서는 결과 중심주의(데이터) 였으며 대부분의 프로그램 코드가 '스파게티 코드' 였음
# go-to 문이라고 해서 코드 자체가 이리저리 왔다갔다 했음

# 이후 3세대로 가면서 '과정 중심주의(알고리즘)' 와 '모듈화(프로시저, 함수)' 로 진행되었고 go-to 문을 없애거나 줄이면서 스파게티 코드가 줄어듬
# 자료구조는 '데이터' 측면에서 바라본 용어이며 , 알고리즘은 '절차적' 측면에서 바라본 용어이나 둘은 같은 의미를 지님

# 4세대로 오면서 다시 결과 중심주의로 돌아왔으나 알고리즘은 '당연히' 기본적으로 깔린 상태에서 정확한 데이터가 나오는 것을 중심으로 함

# 자료 구조
# 자료 구조는 데이터를 효율적으로 저장하고 관리하는 방법을 말함

# 자료구조는 선형 자료 구조와 비선형 자료 구조로 분류됨
# 선형 자료 구조 : 배열 , 연결 리스트 , 스택 , 큐
# 비선형 자료 구조 : 트리 , 그래프
# * 컴퓨터 입장에서 정적인 자료 구조는 빠른 자료 구조를 말하며 , 동적인 자료 구조는 느린 자료 구조를 말함

# 전통적인 알고리즘
# 링크드리스트 / 스택 / 큐 / 더블 링크드리스트 / 수식 전환
# 해쉬 검색 / 퀵 정렬 / 트리 및 트리 순회

# 변수
# [1] C언어는 값 변수와 포인터형 변수 두 개로 나누어짐
# C 언어의 문제가 특정 변수를 값 타입으로도 선언할 수 있고 포인터 타입으로도 선언할 수 있음, 하지만 장점은 OS 나 그 밖에 시스템 프로그램이 모두 코딩 가능함
# 값 변수 : int a = 6; (a 라는 변수와 값 6 전부 스택에 저장됨)
# 포인터형 변수 : int *p; (값은 넣을 수 없으며 주소만 저장되며 사용하기 위해서는 p = &a; / p = new int; 등으로 사용하며 다른 변수의 주소를 저장하거나 힙 공간에 동적으로 할당을 받아야함)

# [2] JAVA 에서는 포인터형 변수를 없애고 '값타입' 과 '참조타입(포인터)' 를 만듬
# JAVA 의 참조타입에는 배열과 객체만 있고, 나머지는 모두 값 타입의 변수임
# 값타입을 때때로 참조타입으로 전환해야할 경우 wrapper 클래스가 있으며 int 는 값타입이지만 Integer 는 참조타입임

# [3] 파이썬에서는 구분을 없애고 전부 참조타입 변수로 만듬(모든 값이 다 heap 에 저장됨)
# 따라서 장점이 C 언어를 그대로 사용할 수 있음
# 파이썬의 모든 변수는 대상 자체가 아니라 대상이 있는 주소만 저장함, 그래서 변수의 타입을 선언할 필요도 없고 사용 방법도 일관적임

# 파이썬의 객체
# 파이썬의 모든 객체는 세 가지 속성을 지님
# [1] 아이덴티티 : 객체를 고유하게 식별하는 값
# [2] 유형 : 객체가 어떤 조율의 데이터를 가리키는 지 나타내는 정보
# [3] 값 : 객체가 실제로 가지고 있는 데이터

# 배열(Array) 의 본래 특징
# [1] 연속된 메모리 공간
# [2] 정적임 - 프로그램 실핸 전에 메모리 크기 확정, 위치 확정 / 수행 도중에 메모리 크기를 늘리거나 줄이거나 또는 위치 이동 불가능(파이썬, 자바도 이 성격 위배됨)
# [3] 인덱싱으로 요소들에 접근할 수 있음
# [4] 같은 타입이어야 함(파이썬은 값의 주소만 저장하기 때문에 리스트에 다양한 타입의 값을 넣을 수 있음)

# 정수 배열에서 가장 큰 수 두 수를 찾기

"""
def findMax(number_list) :
    for index in range(0 , len(number_list)) :
        for index_2 in range(0 , len(number_list) - 1) :
            if number_list[index] > number_list[index_2] :
                number_list[index] , number_list[index_2] = number_list[index_2] , number_list[index]
    
    print(f"가장 큰 수 : {number_list[0]}")
    print(f"두번째로 큰 수 : {number_list[1]}")

if __name__ == "__main__" :
    number_list = [3,-1,5,0,7,4,9,1]
    findMax(number_list)
"""

# 펠린드롬

word = "racecar"

if word == word[::-1] :
    print(True)
else :
    print(False)
    
print(word)
print(word[len(word) - 1])
    
# 절반을 쪼개서 - 길이로 계산

def palindromes(word) :
    left_word = 0
    right_word = len(word) - 1
    
    while left_word < right_word :
        if word[left_word] != word[right_word] :
            return False
        left_word += 1
        right_word -= 1
    return True

Result = palindromes(word)
print(f"{Result}")