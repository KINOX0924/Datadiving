5월 19일 데이터베이스 강의

제약 조건
[1] PrimaryKey
- 중복 불가 및 Null 값을 가지지 않는 필드만 PrimaryKey 로 지정이 가능함
- 삭제나 추가는 가능하지만 수정은 불가함
* 예전에는 회원 아이디를 PrimaryKey 로 주로 지정했었음 / 아이디가 변경이 가능한 사이트들은 별도의 일련번호를 부여하여 PrimaryKey 로 지정
* 그리고 회원 아이디는 UniqueKey(중복은 허용하지 않지만 Null 값은 허용) 로 지정함
* 기본 테이블에 PrimaryKey 는 하나만 줄 수 있음(여러 개의 필드를 묶어서 하나의 PrimaryKey 로 지정할 수 있음)

- PrimaryKey 추가 / 삭제 - MySQL
-- alter : PrimaryKey 수정할 때 사용하는 기본 명령어
         : alter table (테이블명) drop primary key; [ PrimaryKey 삭제 명령어 ]
         : alter table (테이블명) add constaint (Key 이름) primary key (필드명); [ PrimaryKey 추가 명령어 ]


[2] ForeignKey (외래키)
- 테이블과 테이블의 관계성에 입각해서 상호 제약을 가하고자 할 때 사용
- 하기의 일관성(테이블을 나누는 이유) 을 유지하기 위해서 ForeignKey 를 사용해야함
예:)) emp 테이블의 deptno 가 있고 dept 테이블의 deptno 가 있을 때
      emp 테이블에서 ForeignKey 를 dept 테이블에 걸어줌
      emp 테이블의 deptno 필드에는 dept 테이블의 deptno 필드 내에 있는 값만 넣을 수 있게 되어
      만약 emp 테이블에 dept 필드에 없는 값을 넣으려면 값을 넣을 수 없음
      deptno 테이블 입장에서는 emp 테이블에서 deptno 테이블의 값을 참조중이면 삭제가 불가능해짐


[ 테이블을 나누어 관리하는 이유 ]
- 테이블을 나누는 구조(정규화)
- 실무에서 바라볼 때 1 : N 의 관계일 때 테이블을 나눔
* 예:)) 고용인 , 부서 테이블이 있을 때 각 직원마다 부서명을 따로 저장하게 되면 메모리를 너무 많이 차지하게 됨
        또한 부서명을 바꿀 때마다 직원마다 부서명을 바꾸어야 함(이러한 것을 쓸데없는 일 = 오버헤드 라고 함)
        실수로 한명 빼고 바꾸면 '한 명은 홍보부 -> 나머지는 마케팅부' 같은 일이 발생할 수 있음(일관성이 없어짐)
        따라서 테이블을 나누어 관리하면 메모리 부족이 해결되고 오버헤드가 사라짐
        History 테이블을 만들어 관리
        예 1 :)) 대학 등에서 졸업 후 학과명 등이 바뀌었을 때 졸업생이 졸업 증명서를 발급받아도 이전 학과명이 나와야하는 등이 필요할 때
        예 2 :)) 개발 중 데이터베이스를 실수로 삭제하는 등의 일이 발생할 때

        = 결과적으로 일관성을 유지하기 위함




서브 쿼리
- 메인 쿼리의 옆에서 메인 쿼리보다 먼저 실행되서 결과를 가져온 다음에 메인 쿼리가 실행됨
- select 절 : 스칼라 서브 쿼리 : 결과값이 Null 이거나 한 개만 가져오는 쿼리
                   : join 을 대체할 수 있고 사용자가 보기에는 편해보이나 join 보다 속도는 느림
                   : 가급적 join 으로 해결하고 join 으로 해결할 수 없는 상황에서 서브 쿼리를 사용
                   * select 절
                   예:)) select A.empno , A.ename , (select B.dname from dept B where A.deptno = B.deptno) as dname
                         from emp A;
                  * 스칼라 서브 쿼리는 한 번에 한 항목 밖에 가져올 수 없어서 추가 항목을 가져오려면 스칼라 서브 쿼리 한 줄 자체를 더 추가해야함
- from 점 : 다중행 서브 쿼리 : 다중 행을 반환하는 서브 쿼리 , 인라인뷰
                   예:)) select A.ename , B.dname
                         from (
                              select * from emp where deptno in (10, 20)
                         ) as A
                         join dept B on A.deptno = B.deptno;
- where 절 : 